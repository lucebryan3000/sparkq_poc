# SparkQ Phase 3: Server + API + Web UI - Complete Orchestration

> **Total Token Budget:** ~21K tokens
> **Breakdown:** 8K Sonnet (prompt generation) + 13K Haiku (validation) + $0 Codex
> **Codex Cost:** $0 (separate subscription)
> **Duration:** ~3-4 hours
> **Output:** HTTP server with FastAPI, REST API, Web UI for human interaction
> **Execution Model:** Sonnet → Codex (parallel) → Haiku (validation)

---

## Context

You are implementing **SparkQ Phase 3** - the HTTP server, REST API, and Web UI that provides human-friendly access to SparkQ.

**Prerequisites:**
- Phase 1 complete (storage.py, models.py, session/stream CRUD)
- Phase 2 complete (task CRUD, enqueue, peek, claim, complete, fail, requeue)
- SQLite database with WAL mode
- sparkq.yml configuration exists

**Reference Documents:**
- FRD v7.5 Section 6 (Architecture)
- FRD v7.5 Section 14.1 (Setup & Server Commands)
- FRD v7.5 Section 15 (Web UI)
- FRD v7.5 Section 15.4 (API Endpoints)

**Key Constraints:**
- Server binds to `127.0.0.1:8420` only (localhost)
- No authentication (trusted local environment)
- Auto-purge on startup (background task)
- Lockfile prevents multiple server instances

---

## Execution Overview

This phase uses a **3-step orchestration pattern** to optimize token usage:

**Step 1: Sonnet Prompt Generation (8K tokens)**
- Sonnet reads FRD v7.5 + Phase 3 spec
- Generates detailed Codex prompts for each batch (1-2K per batch)
- Includes validation instructions, file paths, exact requirements
- Output: 6 optimized Codex prompts ready for parallel execution

**Step 2: Codex Parallel Execution ($0 cost)**
- 6 Codex commands execute simultaneously in parallel
- Each command creates 1-4 files (16 files total)
- Codex benefits from detailed prompts generated by Sonnet
- Total Codex execution: ~20-30 minutes
- Cost: $0 (separate Codex subscription)

**Step 3: Haiku Validation (~1.5K tokens per batch)**
- After each Codex batch completes, Haiku validates syntax
- 6 batches × ~2K tokens = ~12K tokens total
- Catches errors early before integration
- Minimal latency (Haiku is fast)

**Optional Step 4: Sonnet Review/Integration (0-1K tokens)**
- Optional Sonnet review of any integration issues
- Only if Haiku validation catches errors
- Not needed for smooth execution

---

## Complete Execution Workflow

### Batch 1: FastAPI Server Foundation (Sequential - prerequisite for others)

**Sonnet Task (1.5K tokens):**
- Generate detailed Codex prompt for server.py
- Include exact class/method signatures
- Specify error handling patterns
- Include lockfile logic

**Codex Execution:**
- Command 1: Create server.py with Uvicorn wrapper
- 3 terminal commands execute sequentially
- Creates: server.py file
- Time: ~5 minutes

**Haiku Validation (1.5K tokens):**
```bash
python -m py_compile sparkq/src/server.py
```

**Tokens: 1.5K (Sonnet) + 0 (Codex) + 1.5K (Haiku) = 3K**

---

### Batch 2: API Foundation (Can run after Batch 1)

**Sonnet Task (1.5K tokens):**
- Generate detailed Codex prompt for api.py
- Include FastAPI patterns and CORS setup
- Specify endpoint stub structure
- Include static file serving details

**Codex Execution:**
- Command 2: Create api.py with FastAPI app
- Creates: api.py file
- Time: ~5 minutes

**Haiku Validation (1.5K tokens):**
```bash
python -m py_compile sparkq/src/api.py
```

**Tokens: 1.5K (Sonnet) + 0 (Codex) + 1.5K (Haiku) = 3K**

---

### Batches 3-5: API Endpoints (Parallel - all depend on Batch 2)

Can execute simultaneously once Batch 2 is done.

**Batch 3: Session Endpoints**
- Sonnet: 1K (generate prompt for session endpoints)
- Codex: Modify api.py - add /sessions endpoints
- Haiku: 1.5K (validate python syntax)
- **Total: 2.5K**

**Batch 4: Stream Endpoints**
- Sonnet: 1K (generate prompt for stream endpoints)
- Codex: Modify api.py - add /streams endpoints
- Haiku: 1.5K (validate python syntax)
- **Total: 2.5K**

**Batch 5: Task Endpoints**
- Sonnet: 1K (generate prompt for task endpoints)
- Codex: Modify api.py - add /tasks endpoints
- Haiku: 1.5K (validate python syntax)
- **Total: 2.5K**

---

### Batch 6: CLI Commands (Parallel - can run after Batch 1)

**Sonnet Task (1.5K tokens):**
- Generate 4 detailed Codex prompts (run, stop, status, reload)
- Include signal handling patterns
- Specify server interaction logic
- Include error messages and formatting

**Codex Execution (Parallel - 4 terminals):**
- Command 1: sparkq_run() function
- Command 2: sparkq_stop() function
- Command 3: sparkq_status() function
- Command 4: sparkq_reload() function
- Modifies: cli.py file
- Time: ~5 minutes (all 4 in parallel)

**Haiku Validation (2K tokens):**
```bash
python -m py_compile sparkq/src/cli.py
```

**Tokens: 1.5K (Sonnet) + 0 (Codex) + 2K (Haiku) = 3.5K**

---

### Batch 7: Web UI Core Files (Parallel - independent)

**Sonnet Task (1.5K tokens):**
- Generate 3 detailed Codex prompts (index.html, style.css, app.js)
- Include HTML structure, CSS color scheme, router patterns
- Specify API client wrapper and page component structure
- Include SPA initialization logic

**Codex Execution (Parallel - 3 terminals):**
- Command 1: Create index.html - SPA shell with nav
- Command 2: Create style.css - dark theme styling
- Command 3: Create app.js - router, API client, dashboard
- Creates: 3 UI files
- Time: ~10 minutes (all 3 in parallel)

**Haiku Validation (1.5K tokens):**
- Syntax check for HTML/CSS/JavaScript
- Verify file structure

**Tokens: 1.5K (Sonnet) + 0 (Codex) + 1.5K (Haiku) = 3K**

---

### Batch 8: Web UI Features - Sessions/Streams/Tasks/Enqueue (Parallel - depends on Batch 7)

**Sonnet Task (1.5K tokens):**
- Generate 3 detailed Codex prompts (Sessions/Streams pages, Tasks pages, Enqueue form)
- Include table rendering patterns
- Specify modal components and form validation
- Include API integration for each page

**Codex Execution (Parallel - 3 terminals):**
- Command 1: Add Sessions/Streams pages to app.js
- Command 2: Add Tasks list/detail pages to app.js
- Command 3: Add Enqueue form to app.js
- Modifies: app.js file
- Time: ~10 minutes (all 3 in parallel)

**Haiku Validation (2K tokens):**
- JavaScript syntax for all 3 feature sets
- Verify integration with existing router/API client

**Tokens: 1.5K (Sonnet) + 0 (Codex) + 2K (Haiku) = 3.5K**

---

## Execution Sequence

```
Timeline:
├─ Batch 1 (server.py) - Sequential: 5 min
│  ├─ Sonnet generates prompt (1.5K)
│  ├─ Codex creates file
│  └─ Haiku validates (1.5K)
│
├─ Batch 2 (api.py foundation) - After Batch 1: 5 min
│  ├─ Sonnet generates prompt (1.5K)
│  ├─ Codex creates file
│  └─ Haiku validates (1.5K)
│
├─ PARALLEL BLOCK A (starts after Batch 2):
│  ├─ Batch 3 (session endpoints): 5 min
│  │  ├─ Sonnet generates prompt (1K)
│  │  ├─ Codex modifies api.py
│  │  └─ Haiku validates (1.5K)
│  │
│  ├─ Batch 4 (stream endpoints): 5 min
│  │  ├─ Sonnet generates prompt (1K)
│  │  ├─ Codex modifies api.py
│  │  └─ Haiku validates (1.5K)
│  │
│  └─ Batch 5 (task endpoints): 5 min
│     ├─ Sonnet generates prompt (1K)
│     ├─ Codex modifies api.py
│     └─ Haiku validates (1.5K)
│
├─ Batch 6 (CLI commands) - In parallel with BLOCK A: 5 min
│  ├─ Sonnet generates 4 prompts (1.5K)
│  ├─ Codex modifies cli.py (4 commands)
│  └─ Haiku validates (2K)
│
├─ Batch 7 (Web UI core) - In parallel with BLOCK A: 10 min
│  ├─ Sonnet generates 3 prompts (1.5K)
│  ├─ Codex creates 3 files (HTML/CSS/JS)
│  └─ Haiku validates (1.5K)
│
└─ Batch 8 (Web UI features) - After Batch 7: 10 min
   ├─ Sonnet generates 3 prompts (1.5K)
   ├─ Codex modifies app.js (3 features)
   └─ Haiku validates (2K)

TOTAL WALL-CLOCK TIME: ~25 minutes (with parallelization)
TOTAL TOKEN COST: 21K tokens (8K Sonnet + 13K Haiku + $0 Codex)
```

---

## Phase 3.1: FastAPI Server Setup

### Batch 6 (Foundation - Sequential)

```bash
# Terminal 1: Create server.py with Uvicorn wrapper
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.1 - Server Module
Reference: FRD v7.5 Section 6 (Architecture)

Task: Create src/server.py with Uvicorn wrapper and lockfile handling

File to create: sparkq/src/server.py

Requirements:
- Lockfile at sparkq.lock prevents multiple server instances
- Server binds to 127.0.0.1:8420 only
- Auto-purge background task (runs on startup)
- Signal handling for clean shutdown
- Thread-safe lockfile management

Key Functions:
1. get_pid_from_lockfile() -> Optional[int]
   - Read PID from sparkq.lock file
   - Return int(pid) or None

2. is_process_running(pid: int) -> bool
   - Use os.kill(pid, 0) to check if process exists
   - Return True if running, False if not

3. create_lockfile()
   - Write current os.getpid() to sparkq.lock

4. remove_lockfile()
   - Delete sparkq.lock (handle missing file gracefully)

5. check_server_running() -> Optional[int]
   - Get PID from lockfile
   - If running: return PID
   - If stale: clean up and return None

6. start_auto_purge(storage, older_than_days=3)
   - Background thread
   - Delete tasks with status in ('succeeded', 'failed') older than N days
   - Log deleted count

7. run_server(port=8420, host='127.0.0.1')
   - Check if already running (error if yes)
   - Create lockfile
   - Register cleanup with atexit
   - Handle SIGINT/SIGTERM for clean shutdown
   - Start auto_purge background thread
   - Import api.app and run with uvicorn.run(app, host, port)

Error handling:
- Server already running: 'Error: SparkQ server already running (PID X)\nStop it first with: sparkq stop'

Validation: python -m py_compile sparkq/src/server.py
"
```

```bash
# Terminal 2: Create api.py with FastAPI app
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.1 - FastAPI App
Reference: FRD v7.5 Section 15 (Web UI)

Task: Create src/api.py with FastAPI app, CORS, and health endpoint

File to create: sparkq/src/api.py

Requirements:
- FastAPI app instance
- CORS enabled for localhost
- Health endpoint at GET /health
- Base URL: http://127.0.0.1:8420
- Static file serving for Web UI

Key Components:
1. FastAPI() app
2. CORS middleware: allow_origins=['http://127.0.0.1:8420', 'http://localhost:8420']
3. GET /health endpoint
   - Response: {'status': 'ok', 'timestamp': ISO datetime}
4. Static file mount at /ui for serving HTML/CSS/JS
   - Mount path: /ui
   - Directory: ./sparkq/ui
   - HTML: index.html as default

Additional endpoints (stubs for now):
- GET /api/sessions (list sessions)
- GET /api/streams (list streams)
- GET /api/tasks (list tasks)

Validation: python -m py_compile sparkq/src/api.py
"
```

---

## Phase 3.2: API Endpoints

### Batch 7 (Parallel - all 3 API route sets)

```bash
# Terminal 1: Add Session endpoints
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.2 - Session Endpoints
Reference: FRD v7.5 Section 15.4 (API Endpoints)

Task: Add Session endpoints to src/api.py

File to modify: sparkq/src/api.py

Endpoints to add:

1. GET /api/sessions
   - List all sessions
   - Query params: filter_status (optional)
   - Response: {'sessions': [session dicts]}
   - Call: storage.list_sessions()

2. POST /api/sessions
   - Create new session
   - Body: {'name': str, 'instructions': str (optional)}
   - Response: {'session': session_dict}
   - Call: storage.create_session(name, instructions)

3. GET /api/sessions/{session_id}
   - Get session by ID
   - Response: {'session': session_dict}
   - Error 404 if not found

4. PUT /api/sessions/{session_id}
   - Update session
   - Body: {'instructions': str (optional)}
   - Response: {'session': updated_dict}
   - Call: storage.update_session(session_id, instructions)

5. PUT /api/sessions/{session_id}/end
   - End session (soft delete)
   - Response: {'message': 'Session ended'}
   - Call: storage.end_session(session_id)

Storage integration:
- Import Storage from .storage
- Create storage instance: storage = Storage()
- All responses wrap data in JSON

Error handling:
- 404 if session not found
- 400 for invalid request body

Validation: python -m py_compile sparkq/src/api.py
"
```

```bash
# Terminal 2: Add Stream endpoints
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.2 - Stream Endpoints
Reference: FRD v7.5 Section 15.4 (API Endpoints)

Task: Add Stream endpoints to src/api.py

File to modify: sparkq/src/api.py

Endpoints to add:

1. GET /api/streams
   - List all streams
   - Query params: session_id (optional filter)
   - Response: {'streams': [stream dicts]}
   - Call: storage.list_streams()

2. POST /api/streams
   - Create new stream
   - Body: {'name': str, 'session_id': str, 'instructions': str (optional)}
   - Response: {'stream': stream_dict}
   - Call: storage.create_stream(session_id, name, instructions)

3. GET /api/streams/{stream_id}
   - Get stream by ID
   - Response: {'stream': stream_dict}
   - Error 404 if not found

4. PUT /api/streams/{stream_id}
   - Update stream
   - Body: {'instructions': str (optional)}
   - Response: {'stream': updated_dict}
   - Call: storage.update_stream(stream_id, instructions)

5. PUT /api/streams/{stream_id}/end
   - End stream (soft delete)
   - Response: {'message': 'Stream ended'}
   - Call: storage.end_stream(stream_id)

Storage integration:
- Same as Session endpoints
- All method calls on Storage instance

Error handling:
- 404 if stream not found
- 404 if session not found (when creating stream)

Validation: python -m py_compile sparkq/src/api.py
"
```

```bash
# Terminal 3: Add Task endpoints
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.2 - Task Endpoints
Reference: FRD v7.5 Section 15.4 (API Endpoints)

Task: Add Task endpoints to src/api.py

File to modify: sparkq/src/api.py

Endpoints to add:

1. GET /api/tasks
   - List all tasks
   - Query params: stream_id, status, limit
   - Response: {'tasks': [task dicts]}
   - Call: storage.list_tasks(stream_id, status, limit)

2. POST /api/tasks
   - Create new task
   - Body: {'stream_id': str, 'tool_name': str, 'task_class': str, 'timeout': int (optional), 'prompt_path': str (optional)}
   - Response: {'task': task_dict}
   - Call: storage.create_task(...)

3. GET /api/tasks/{task_id}
   - Get task by ID
   - Response: {'task': task_dict}
   - Error 404 if not found

4. POST /api/tasks/{task_id}/claim
   - Claim a task
   - Response: {'task': claimed_task_dict}
   - Call: storage.claim_task(task_id)

5. POST /api/tasks/{task_id}/complete
   - Mark task complete
   - Body: {'result_summary': str, 'result_data': str (optional)}
   - Response: {'task': completed_task_dict}
   - Call: storage.complete_task(task_id, result_summary, result_data)

6. POST /api/tasks/{task_id}/fail
   - Mark task failed
   - Body: {'error_message': str, 'error_type': str (optional)}
   - Response: {'task': failed_task_dict}
   - Call: storage.fail_task(task_id, error_message, error_type)

7. POST /api/tasks/{task_id}/requeue
   - Requeue task
   - Response: {'task': requeued_task_dict}
   - Call: storage.requeue_task(task_id)

Error handling:
- 404 if task not found
- 400 for invalid request body
- 409 for invalid state transitions

Validation: python -m py_compile sparkq/src/api.py
"
```

---

## Phase 3.3: CLI Run/Stop/Status/Reload Commands

### Batch 8 (Parallel - 4 CLI commands)

```bash
# Terminal 1: Implement run command
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.3 - Run Command
Reference: FRD v7.5 Section 14.1

Task: Implement sparkq_run() function in sparkq/src/cli.py

File to modify: sparkq/src/cli.py

Function signature:
def sparkq_run(
    session: Optional[str] = typer.Option(None, help='Session name to enter'),
    port: int = typer.Option(8420, help='Server port')
):

Implementation:
1. Import from .server import run_server
2. Call run_server(port=port)
3. Server starts Uvicorn and blocks
4. On interrupt (Ctrl+C): clean shutdown with lockfile removal
5. Output: 'SparkQ server running at http://127.0.0.1:{port}'

If session parameter:
- Use session as default in Web UI (optional enhancement for Phase 5)

Error handling:
- Server already running: error from run_server (propagate)
- Port in use: Uvicorn error (propagate)

Validation: python -m py_compile sparkq/src/cli.py
"
```

```bash
# Terminal 2: Implement stop command
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.3 - Stop Command
Reference: FRD v7.5 Section 14.1

Task: Implement sparkq_stop() function in sparkq/src/cli.py

File to modify: sparkq/src/cli.py

Function signature:
def sparkq_stop():

Implementation:
1. Read PID from sparkq.lock
   - Error if file not found: 'Error: Server not running'
2. Check if process is running
   - Error if not running: 'Error: Server not running'
3. Send SIGTERM to process: os.kill(pid, signal.SIGTERM)
4. Wait up to 5 seconds for graceful shutdown
5. If still running: send SIGKILL: os.kill(pid, signal.SIGKILL)
6. Delete sparkq.lock file
7. Output: 'SparkQ server stopped'

Error handling:
- Server not running: 'Error: Server not running'
- Permission denied: 'Error: Permission denied (already running as different user?)'

Validation: python -m py_compile sparkq/src/cli.py
"
```

```bash
# Terminal 3: Implement status command
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.3 - Status Command
Reference: FRD v7.5 Section 14.1

Task: Implement sparkq_status() function in sparkq/src/cli.py

File to modify: sparkq/src/cli.py

Function signature:
def sparkq_status():

Implementation:
1. Read PID from sparkq.lock (if exists)
2. If no lockfile: Output 'SparkQ server: not running'
3. If lockfile exists:
   a. Check if PID is running: os.kill(pid, 0)
   b. If running: try to reach health endpoint
   c. GET http://127.0.0.1:8420/health (with 2s timeout)
4. Output format:
   - If running + healthy: 'SparkQ server: running (PID X, http://127.0.0.1:8420)'
   - If running but unreachable: 'SparkQ server: running but API unreachable (PID X)'
   - If not running: 'SparkQ server: not running'

Graceful handling:
- Suppress timeout exceptions
- Suppress connection errors
- Assume running if PID exists, even if API unreachable

Validation: python -m py_compile sparkq/src/cli.py
"
```

```bash
# Terminal 4: Implement reload command
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.3 - Reload Command
Reference: FRD v7.5 Section 14.1

Task: Implement sparkq_reload() function in sparkq/src/cli.py

File to modify: sparkq/src/cli.py

Function signature:
def sparkq_reload():

Implementation:
1. Import reload_registry from .tools
2. Call reload_registry()
3. Output: 'Tool registry reloaded'
4. (Phase 5: Also rebuild script index)

Error handling:
- Config file not found: 'Error: sparkq.yml not found'
- Invalid YAML: 'Error: Invalid YAML in sparkq.yml'

Validation: python -m py_compile sparkq/src/cli.py
"
```

---

## Phase 3.4: Web UI (HTML + CSS + JS)

### Batch 9 (Parallel - 3 core + 3 features = 6 files)

```bash
# Terminal 1: Create Web UI shell (index.html)
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.4 - Web UI Shell
Reference: FRD v7.5 Section 15 (Web UI)

Task: Create sparkq/ui/index.html - SPA shell with navigation

File to create: sparkq/ui/index.html

Requirements:
- Single Page Application (SPA) shell
- Navigation bar with tabs: Dashboard, Sessions, Streams, Tasks, Enqueue
- Dark theme (modern dark background)
- Status indicators (running, idle, error)
- Responsive layout

Structure:
1. <!DOCTYPE html>
2. <head>
   - Meta tags (charset, viewport)
   - Title: 'SparkQ'
   - Link to style.css
3. <body>
   - <nav> with tabs
   - <main id='app'> for content
   - Script loading app.js
4. Navigation items:
   - Dashboard
   - Sessions
   - Streams
   - Tasks
   - Enqueue
   - Status indicator

CSS classes:
- .navbar, .nav-tabs, .tab-content
- .status-indicator, .status-running, .status-idle
- .container, .header, .footer

Validation: HTML syntax validation (can open in browser)
"
```

```bash
# Terminal 2: Create Web UI stylesheet (style.css)
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.4 - Web UI Stylesheet
Reference: FRD v7.5 Section 15 (Web UI)

Task: Create sparkq/ui/style.css - Dark theme with status indicators

File to create: sparkq/ui/style.css

Requirements:
- Dark theme (dark background, light text)
- Status indicators (green=running, yellow=idle, red=error)
- Responsive design
- Clean typography

Color scheme:
- Background: #1a1a1a (dark)
- Text: #e0e0e0 (light)
- Accent: #4a9eff (blue)
- Status running: #4caf50 (green)
- Status idle: #ffc107 (yellow)
- Status error: #f44336 (red)

Key styles:
1. Body, .container - global layout
2. .navbar - navigation bar styling
3. .nav-tabs - tab styling (active state)
4. .tab-content - content area styling
5. .table - task/session table styling
6. .button - button styling (primary, secondary)
7. .input-group - form input styling
8. .status-indicator - status badge styling
9. .alert - error/success message styling
10. .loading - loading spinner styling

Validation: CSS syntax (can apply to HTML)
"
```

```bash
# Terminal 3: Create Web UI application (app.js)
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.4 - Web UI Application
Reference: FRD v7.5 Section 15 (Web UI)

Task: Create sparkq/ui/app.js - SPA router, API client, dashboard

File to create: sparkq/ui/app.js

Requirements:
- Simple SPA router (hash-based)
- Fetch wrapper with error handling
- Dashboard page with stats
- Page containers for Sessions, Streams, Tasks, Enqueue

Key Components:
1. API Client
   - fetch wrapper: api(method, path, body=null)
   - Base URL: http://127.0.0.1:8420/api
   - Error handling: show alert on API errors

2. Router
   - Hash-based routing (#dashboard, #sessions, #streams, #tasks, #enqueue)
   - Router function to show/hide page content
   - Active tab highlighting

3. Dashboard Page
   - Show server status (health check)
   - Display stats: session count, stream count, queued tasks, running tasks
   - Refresh stats every 10 seconds

4. Page Containers (initially empty, will be filled by feature modules)
   - #dashboard-page
   - #sessions-page
   - #streams-page
   - #tasks-page
   - #enqueue-page

5. Initialization
   - On page load: set up router, show dashboard
   - Set up tab click handlers
   - Start status polling

Validation: JavaScript syntax check (can load in browser console)
"
```

```bash
# Terminal 4: Add Sessions/Streams pages to app.js
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.4 - Sessions & Streams Pages
Reference: FRD v7.5 Section 15 (Web UI)

Task: Add Sessions and Streams pages to sparkq/ui/app.js

File to modify: sparkq/ui/app.js

Add to app.js:

1. renderSessionsPage()
   - Fetch sessions: GET /api/sessions
   - Display as table: ID | Name | Created | Status
   - Add 'Create Session' button
   - Add 'End Session' button for each row
   - Show 'No sessions' if empty

2. renderStreamsPage()
   - Fetch streams: GET /api/streams
   - Display as table: ID | Session | Name | Created | Task Count
   - Add 'Create Stream' button
   - Add 'End Stream' button for each row
   - Show 'No streams' if empty

3. renderCreateSessionModal()
   - Form with: name (text), instructions (textarea)
   - Submit button: creates session via POST /api/sessions
   - Cancel button

4. renderCreateStreamModal()
   - Form with: name (text), session_id (dropdown of sessions), instructions (textarea)
   - Submit button: creates stream via POST /api/streams
   - Cancel button

5. Modal integration
   - Show modals as overlays
   - Close on cancel or successful submit
   - Refresh page list after successful operation

Validation: JavaScript syntax check
"
```

```bash
# Terminal 5: Add Task pages to app.js
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.4 - Task Pages
Reference: FRD v7.5 Section 15 (Web UI)

Task: Add Task list and detail pages to sparkq/ui/app.js

File to modify: sparkq/ui/app.js

Add to app.js:

1. renderTasksPage()
   - Fetch tasks: GET /api/tasks
   - Display as table: ID | Stream | Tool | Status | Created
   - Filter options: stream (dropdown), status (dropdown)
   - Click task row to show detail modal
   - Show 'No tasks' if empty

2. renderTaskDetailModal(taskId)
   - Fetch task: GET /api/tasks/{taskId}
   - Show: ID, Stream, Tool, Status, Created, Claimed, Completed/Failed
   - Show prompt text (if available)
   - Show result/error text (if available)
   - Action buttons based on status:
     a. If queued: 'Claim' button (POST /api/tasks/{taskId}/claim)
     b. If claimed: 'Complete' button, 'Fail' button
     c. If failed/succeeded: 'Requeue' button
   - Close button

3. renderTaskCompleteModal(taskId)
   - Form with: result_summary (text), result_data (textarea)
   - Submit: POST /api/tasks/{taskId}/complete
   - Cancel button

4. renderTaskFailModal(taskId)
   - Form with: error_message (text), error_type (text)
   - Submit: POST /api/tasks/{taskId}/fail
   - Cancel button

5. Task actions
   - Claim, Complete, Fail, Requeue buttons
   - Show confirmation on destructive actions
   - Refresh task detail after action

Validation: JavaScript syntax check
"
```

```bash
# Terminal 6: Add Enqueue form to app.js
codex exec --full-auto -C /home/luce/apps/sparkqueue "
Context: SparkQ Phase 3.4 - Enqueue Form
Reference: FRD v7.5 Section 14.4

Task: Add Enqueue form to sparkq/ui/app.js

File to modify: sparkq/ui/app.js

Add to app.js:

1. renderEnqueuePage()
   - Form with fields:
     a. stream (dropdown - fetch from GET /api/streams)
     b. tool (text input - for tool name)
     c. task_class (dropdown: FAST_SCRIPT, MEDIUM_SCRIPT, LLM_LITE, LLM_HEAVY)
     d. timeout (number input, optional)
     e. prompt_content (textarea, optional)
     f. metadata (textarea JSON, optional)
   - Submit button: 'Enqueue Task'
   - Success message after submit
   - Clear form after successful submit

2. Enqueue submission
   - POST /api/tasks
   - Body: {stream_id, tool_name, task_class, timeout, prompt_path or prompt_content}
   - Show success: 'Task {task_id} enqueued'
   - Show error: display API error message

3. Form validation
   - stream is required
   - tool is required
   - Show validation errors inline

Validation: JavaScript syntax check
"
```

---

## Execution Summary

**9 batches total:**
1. Server foundation (2 files: server.py, api.py)
2. API endpoints - Sessions, Streams, Task (3 parallel endpoints)
3. CLI commands - run, stop, status, reload (4 parallel)
4. Web UI core - index.html, style.css, app.js (3 parallel)
5. Web UI features - Sessions/Streams, Tasks, Enqueue (3 parallel)

Token cost: Validation only (~0.07K tokens)
Codex cost: $0 (separate subscription)
All code integrates with Phase 1 + 2
